///
/// YOCTO_GLTF: Khronos GLTF loader and writer for Khronos glTF format. Supports
/// all the glTF spec and the Khronos extensions. All parsing and writing code
/// is autogenerated form the schema.
///
/// Supported version and extensions.
/// - glTF v. 1.1
/// - KHR_materials_common (draft); this will be updated to the new draft soon
/// - KHR_binary_glTF
///
/// This library will track the spec which is not only a draft. So expect
/// incompatibilities as the draft evolves. For example, top level dictionaries
/// have move to arrays and PBR is in the core. The library gets updated every
/// time a new draft is avaiable.
///
///
/// USAGE FOR READING:
///
/// 1. load a gltf with load_gltf() for ascii gltf or load_gltf_binary() for the
///       binary version
/// 2. [LOW-LEVEL INTERFACE] access the data directly from the returned object
///   - the data is documented below and matches the GLTF file structure exactly
/// 3. [HIGH-LEVEL INTERFACE] optionally flatten the data as a more friendly
///    representation where shapes are index meshes, supporting points, lines
///    and triangle primitives with flatten_gltf()
///   - the flattened data, documented below, can be use to draw directly on
///   the GPU or in a raytracer
///
/// The interface for each function is described in details in the interface
/// section of this file.
///
/// In the high level interface, shapes are indexed meshes and are described
/// by arrays of vertex indices for points/lines/triangles and arrays for vertex
/// positions, normals, texcoords and colors.
///
///
/// USAGE FOR WRITING:
///
/// 1. include this file (more compilation options below)
/// 2. [LOW-LEVEL INTERFACE] fill a gltf object with your scene data and save
///    the gltf and binary data with save_gltf()
///    ok = save_gltf(filename, obj, error message, flags)
/// 3. [HIGH_LEVEL INTERFACE] create a flattened scene object and turn into a
///    gltf with unflatten_gltf()
///
/// The interface for each function is described in details in the interface
/// section of this file.
///
///
/// COMPILATION:
///
/// To use the library include the .h and compile the .cpp. To use this library
/// as a header-only library, define YGLTF_INLINE before including this file.
///
/// JSON loading depends on json.hpp.
/// Texture loading/saving depends on yocto_image.h.
///
/// If the texture loading/saving dependency is not desired, it can be disabled
/// by defining YGLTF_NO_IMAGE before including this file.
///
///
/// HISTORY:
/// - v 0.6: switch to .h/.cpp pair
/// - v 0.5: bug fixes and added checks for missing files
/// - v 0.4: internally use pointers for performance transaprency
/// - v 0.4: doxygen documentation
/// - v 0.3: load/write interface with exceptions
/// - v 0.2: doxygen comments
/// - v 0.1: bug fix when writing names
/// - v 0.0: initial release
///
namespace ygltf {}

//
// LICENSE:
//
// Copyright (c) 2016 -- 2017 Fabio Pellacini
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//

//
// LICENSE OF INCLUDED CODE
//
//
// base64.cpp and base64.h
//
// Copyright (C) 2004-2008 René Nyffenegger
//
// This source code is provided 'as-is', without any express or implied
// warranty. In no event will the author be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this source code must not be misrepresented; you must not
// claim that you wrote the original source code. If you use this source code
// in a product, an acknowledgment in the product documentation would be
// appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original source code.
//
// 3. This notice may not be removed or altered from any source distribution.
//
// René Nyffenegger rene.nyffenegger@adp-gmbh.ch
//

#ifndef _YGLTF_H_
#define _YGLTF_H_

// compilation options
#ifdef YGLTF_INLINE
#define YGLTF_API inline
#else
#define YGLTF_API
#endif

#include <array>
#include <map>
#include <string>
#include <tuple>
#include <vector>

#include "ext/json.hpp"

// -----------------------------------------------------------------------------
// LOW-LEVEL INTERFACE
// -----------------------------------------------------------------------------

namespace ygltf {

// portable deprecation warnings
#if defined(__clang__) || defined(__GNUC__) || defined(__GNUG__)
#define YGL_DEPRECATED __attribute__((deprecated))
#elif defined(_MSC_VER)
#define YGL_DEPRECATED __declspec(deprecated)
#else
#define YGL_DEPRECATED
#endif

///
/// Optional type. Will be sustituted with std::optional once compilers support
/// it.
///
template <typename T>
struct optional {
    /// value
    T value;
    /// whether it is valid (use operator bool)
    bool valid = false;

    /// Initialize to empty object
    optional() {}
    /// Initialize to a value
    optional(const T& value) : value(value), valid(true) {}

    /// Check if it is valid
    operator bool() const { return valid; }
};

///
/// Json alias
///
using json = nlohmann::json;

///
/// Shader data
///
using shader_data_t = std::string;

///
/// Generic buffer data.
///
using buffer_data_t = std::vector<unsigned char>;

///
/// Generic image data.
///
struct image_data_t {
    /// Width
    int width;

    /// Height
    int height;

    /// Number of Channels
    int ncomp;

    /// Buffer data for 8-bit images
    std::vector<uint8_t> datab;

    /// Buffer data for float images
    std::vector<float> dataf;
};

///
/// Extensions
///
using extension_t = std::map<std::string, json>;

///
/// Extras
///
using extras_t = json;

// #codegen begin type ---------------------------------------------------------
///
/// No description in schema.
///
struct glTFProperty_t {
    /// No description in schema.
    extension_t extensions;
    /// No description in schema.
    extras_t extras;
};

///
/// No description in schema.
///
struct glTFChildOfRootProperty_t : glTFProperty_t {
    /// The user-defined name of this object.
    std::string name;
};

///
/// A typed view into a bufferView.  A bufferView contains raw binary data.  An
/// accessor provides a typed view into a bufferView or a subset of a bufferView
/// similar to how WebGL's `vertexAttribPointer()` defines an attribute in a
/// buffer.
///
struct accessor_t : glTFChildOfRootProperty_t {
    /// Values for componentType
    enum struct componentType_t {
        byte_t = 5120,
        unsigned_byte_t = 5121,
        short_t = 5122,
        unsigned_short_t = 5123,
        unsigned_int_t = 5125,
        float_t = 5126,
    };

    /// Values for type
    enum struct type_t {
        scalar_t = 0,
        vec2_t = 1,
        vec3_t = 2,
        vec4_t = 3,
        mat2_t = 4,
        mat3_t = 5,
        mat4_t = 6,
    };

    /// The ID of the bufferView. [required]
    std::string bufferView;
    /// The offset relative to the start of the bufferView in bytes. [required]
    int byteOffset;
    /// The stride, in bytes, between attributes referenced by this accessor.
    int byteStride = 0;
    /// The datatype of components in the attribute. [required]
    componentType_t componentType;
    /// The number of attributes referenced by this accessor. [required]
    int count;
    /// Maximum value of each component in this attribute. [required]
    std::vector<float> max;
    /// Minimum value of each component in this attribute. [required]
    std::vector<float> min;
    /// Specifies whether integer data values should be normalized.
    bool normalized = false;
    /// Specifies if the attribute is a scalar, vector, or matrix. [required]
    type_t type;
};

///
/// The ID of the node and TRS property that an animation channel targets.
///
struct animation_channel_target_t : glTFProperty_t {
    /// Values for path
    enum struct path_t {
        translation_t = 0,
        rotation_t = 1,
        scale_t = 2,
    };

    /// The ID of the node to target. [required]
    std::string id;
    /// The name of the node's TRS property to modify. [required]
    path_t path;
};

///
/// Targets an animation's sampler at a node's property.
///
struct animation_channel_t : glTFProperty_t {
    /// The ID of a sampler in this animation used to compute the value for the
    /// target. [required]
    std::string sampler;
    /// The ID of the node and TRS property to target. [required]
    animation_channel_target_t target;
};

///
/// Combines input and output accessors with an interpolation algorithm to
/// define a keyframe graph (but not its target).
///
struct animation_sampler_t : glTFProperty_t {
    /// Values for interpolation
    enum struct interpolation_t {
        linear_t = 0,
        step_t = 1,
    };

    /// The ID of an accessor containing keyframe input values, e.g., time.
    /// [required]
    std::string input;
    /// Interpolation algorithm.
    interpolation_t interpolation = interpolation_t::linear_t;
    /// The ID of an accessor, containing keyframe output values. [required]
    std::string output;
};

///
/// A keyframe animation.
///
struct animation_t : glTFChildOfRootProperty_t {
    /// An array of channels, each of which targets an animation's sampler at a
    /// node's property. Different channels of the same animation can't have
    /// equal targets.
    std::vector<animation_channel_t> channels;
    /// A dictionary object of samplers that combines input and output accessors
    /// with an interpolation algorithm to define a keyframe graph (but not its
    /// target).
    std::map<std::string, animation_sampler_t> samplers;
};

///
/// Specifies the target rendering API and version, e.g., WebGL 1.0.
///
struct asset_profile_t : glTFProperty_t {
    /// Specifies the target rendering API.
    std::string api = "WebGL";
    /// The API version.
    std::string version = "1.0";
};

///
/// Metadata about the glTF asset.
///
struct asset_t : glTFProperty_t {
    /// A copyright message suitable for display to credit the content creator.
    std::string copyright;
    /// Tool that generated this glTF model.  Useful for debugging.
    std::string generator;
    /// Specifies if the shaders were generated with premultiplied alpha.
    bool premultipliedAlpha = false;
    /// No description in schema.
    asset_profile_t profile;
    /// The glTF version. [required]
    std::string version;
};

///
/// A buffer points to binary geometry, animation, or skins.
///
struct buffer_t : glTFChildOfRootProperty_t {
    /// The length of the buffer in bytes. [required]
    int byteLength = 0;
    /// The uri of the buffer. [required]
    std::string uri;

    /// loaded buffer data
    buffer_data_t data;
};

///
/// A view into a buffer generally representing a subset of the buffer.
///
struct bufferView_t : glTFChildOfRootProperty_t {
    /// Values for target
    enum struct target_t {
        array_buffer_t = 34962,
        element_array_buffer_t = 34963,
    };

    /// The ID of the buffer. [required]
    std::string buffer;
    /// The length of the bufferView in bytes. [required]
    int byteLength;
    /// The offset into the buffer in bytes. [required]
    int byteOffset;
    /// The target that the WebGL buffer should be bound to.
    target_t target;
};

///
/// An orthographic camera containing properties to create an orthographic
/// projection matrix.
///
struct camera_orthographic_t : glTFProperty_t {
    /// The floating-point horizontal magnification of the view. [required]
    float xmag;
    /// The floating-point vertical magnification of the view. [required]
    float ymag;
    /// The floating-point distance to the far clipping plane. [required]
    float zfar;
    /// The floating-point distance to the near clipping plane. [required]
    float znear;
};

///
/// A perspective camera containing properties to create a perspective
/// projection matrix.
///
struct camera_perspective_t : glTFProperty_t {
    /// The floating-point aspect ratio of the field of view.
    float aspectRatio;
    /// The floating-point vertical field of view in radians. [required]
    float yfov;
    /// The floating-point distance to the far clipping plane.
    float zfar;
    /// The floating-point distance to the near clipping plane. [required]
    float znear;
};

///
/// A camera's projection.  A node can reference a camera ID to apply a
/// transform to place the camera in the scene.
///
struct camera_t : glTFChildOfRootProperty_t {
    /// Values for type
    enum struct type_t {
        perspective_t = 0,
        orthographic_t = 1,
    };

    /// An orthographic camera containing properties to create an orthographic
    /// projection matrix.
    camera_orthographic_t orthographic;
    /// A perspective camera containing properties to create a perspective
    /// projection matrix.
    camera_perspective_t perspective;
    /// Specifies if the camera uses a perspective or orthographic projection.
    /// [required]
    type_t type;
};

///
/// No description in schema.
///
struct image_KHR_binary_glTF_t {
    /// The id (JSON property name) of the buffer-view that references the
    /// image. Use this instead of the image's uri property. [required]
    std::string bufferView;
    /// The height of the image in pixels. [required]
    int height;
    /// The image's MIME type. [required]
    std::string mimeType;
    /// The width of the image in pixels. [required]
    int width;
};

///
/// Image data used to create a texture.
///
struct image_t : glTFChildOfRootProperty_t {
    /// The uri of the image. [required]
    std::string uri;
    /// [extension] See image_KHR_binary_glTF_t
    optional<image_KHR_binary_glTF_t> KHR_binary_glTF;

    /// loaded image data
    image_data_t data;
};

///
/// No description in schema.
///
struct material_values_KHR_materials_common_t {
    /// Per-component factors to apply to values of ambientTexture.
    std::array<float, 3> ambientFactor = {0, 0, 0};
    /// ID of RGB texture defining the amount of ambient light reflected from
    /// the surface of the object.
    std::string ambientTexture = "";
    /// Per-component factors to apply to values of diffuseTexture.
    std::array<float, 4> diffuseFactor = {0, 0, 0, 1};
    /// ID of RGBA texture defining the amount of light diffusely reflected from
    /// the surface of the object.
    std::string diffuseTexture = "";
    /// Per-component factors to apply to values of emissionTexture.
    std::array<float, 3> emissionFactor = {0, 0, 0};
    /// ID of RGB texture for defining the amount of light emitted by the
    /// surface of the object.
    std::string emissionTexture = "";
    /// Specularity or roughness of the specular reflection lobe of the object.
    float shininess = 0;
    /// Per-component factors to apply to values of specularTexture.
    std::array<float, 3> specularFactor = {0, 0, 0};
    /// ID of RGB texture defining the amount of light specularly reflected from
    /// the surface of the object.
    std::string specularTexture = "";
    /// Amount of transparency as an opacity value between 0.0 and 1.0.
    float transparency = 1;
};

///
/// KHR_materials_common material extension.
///
struct material_KHR_materials_common_t {
    /// Declares whether backface culling should be disabled for this visual.
    /// Corresponds to disabling the CULL_FACE render state.
    bool doubleSided = false;
    /// Declares maximum number of joints used by meshes which use this
    /// material. This allows to pre-generate vertex shader skinning code before
    /// mesh loading.
    int jointCount = 0;
    /// Specifies the material type. [required]
    std::string technique;
    /// Declares whether the visual should be rendered using alpha blending.
    /// Corresponds to enabling the BLEND render state, setting the depthMask
    /// property to false, and defining blend equations and blend functions as
    /// described in the implementation note.
    bool transparent = false;
    /// A dictionary object of parameter values.
    material_values_KHR_materials_common_t values;
};

///
/// Array values. Only one vector will be full at any one time.
///
struct arrayValues_t {
    /// number items
    std::vector<float> items_number;
    /// string items
    std::vector<std::string> items_string;
    /// boolean items
    std::vector<bool> items_boolean;
};
///
/// The material appearance of a primitive.
///
struct material_t : glTFChildOfRootProperty_t {
    /// The ID of the technique.
    std::string technique;
    /// A dictionary object of parameter values.
    std::map<std::string, arrayValues_t> values;
    /// [extension] See material_KHR_materials_common_t
    optional<material_KHR_materials_common_t> KHR_materials_common;
};

///
/// Geometry to be rendered with the given material.
///
struct mesh_primitive_t : glTFProperty_t {
    /// Values for mode
    enum struct mode_t {
        points_t = 0,
        lines_t = 1,
        line_loop_t = 2,
        line_strip_t = 3,
        triangles_t = 4,
        triangle_strip_t = 5,
        triangle_fan_t = 6,
    };

    /// A dictionary object of strings, where each string is the ID of the
    /// accessor containing an attribute. [required]
    std::map<std::string, std::string> attributes;
    /// The ID of the accessor that contains the indices.
    std::string indices;
    /// The ID of the material to apply to this primitive when rendering.
    std::string material;
    /// The type of primitives to render.
    mode_t mode = mode_t::triangles_t;
};

///
/// A set of primitives to be rendered.  A node can contain one or more meshes.
/// A node's transform places the mesh in the scene.
///
struct mesh_t : glTFChildOfRootProperty_t {
    /// An array of primitives, each defining geometry to be rendered with a
    /// material. [required]
    std::vector<mesh_primitive_t> primitives;
};

///
/// No description in schema.
///
struct node_KHR_materials_common_t {
    /// The id of the light referenced by this node.
    std::string light;
};

///
/// A node in the node hierarchy.  A node can have either the `camera`,
/// `meshes`, or `skeletons`/`skin`/`meshes` properties defined.  In the later
/// case, all `primitives` in the referenced `meshes` contain `JOINT` and
/// `WEIGHT` attributes and the referenced `material`/`technique` from each
/// `primitive` has parameters with `JOINT` and `WEIGHT` semantics.  A node can
/// have either a `matrix` or any combination of
/// `translation`/`rotation`/`scale` (TRS) properties. TRS properties are
/// converted to matrices and postmultiplied in the `T * R * S` order to compose
/// the transformation matrix; first the scale is applied to the vertices, then
/// the rotation, and then the translation. If none are provided, the transform
/// is the identity. When a node is targeted for animation (referenced by an
/// animation.channel.target), only TRS properties may be present; `matrix` will
/// not be present.
///
struct node_t : glTFChildOfRootProperty_t {
    /// The ID of the camera referenced by this node.
    std::string camera;
    /// The IDs of this node's children.
    std::vector<std::string> children;
    /// Name used when this node is a joint in a skin.
    std::string jointName;
    /// A floating-point 4x4 transformation matrix stored in column-major order.
    std::array<float, 16> matrix = {
        1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
    /// The IDs of the meshes in this node.
    std::vector<std::string> meshes;
    /// The node's unit quaternion rotation in the order (x, y, z, w), where w
    /// is the scalar.
    std::array<float, 4> rotation = {0, 0, 0, 1};
    /// The node's non-uniform scale.
    std::array<float, 3> scale = {1, 1, 1};
    /// The ID of skeleton nodes.
    std::vector<std::string> skeletons;
    /// The ID of the skin referenced by this node.
    std::string skin;
    /// The node's translation.
    std::array<float, 3> translation = {0, 0, 0};
    /// [extension] See node_KHR_materials_common_t
    optional<node_KHR_materials_common_t> KHR_materials_common;
};

///
/// A shader program, including its vertex and fragment shader, and names of
/// vertex shader attributes.
///
struct program_t : glTFChildOfRootProperty_t {
    /// Names of GLSL vertex shader attributes.
    std::vector<std::string> attributes;
    /// The ID of the fragment shader. [required]
    std::string fragmentShader;
    /// The ID of the vertex shader. [required]
    std::string vertexShader;
};

///
/// Texture sampler properties for filtering and wrapping modes.
///
struct sampler_t : glTFChildOfRootProperty_t {
    /// Values for magFilter
    enum struct magFilter_t {
        nearest_t = 9728,
        linear_t = 9729,
    };

    /// Values for minFilter
    enum struct minFilter_t {
        nearest_t = 9728,
        linear_t = 9729,
        nearest_mipmap_nearest_t = 9984,
        linear_mipmap_nearest_t = 9985,
        nearest_mipmap_linear_t = 9986,
        linear_mipmap_linear_t = 9987,
    };

    /// Values for wrapS
    enum struct wrapS_t {
        clamp_to_edge_t = 33071,
        mirrored_repeat_t = 33648,
        repeat_t = 10497,
    };

    /// Values for wrapT
    enum struct wrapT_t {
        clamp_to_edge_t = 33071,
        mirrored_repeat_t = 33648,
        repeat_t = 10497,
    };

    /// Magnification filter.
    magFilter_t magFilter = magFilter_t::linear_t;
    /// Minification filter.
    minFilter_t minFilter = minFilter_t::nearest_mipmap_linear_t;
    /// s wrapping mode.
    wrapS_t wrapS = wrapS_t::repeat_t;
    /// t wrapping mode.
    wrapT_t wrapT = wrapT_t::repeat_t;
};

///
/// The root nodes of a scene.
///
struct scene_t : glTFChildOfRootProperty_t {
    /// The IDs of each root node.
    std::vector<std::string> nodes;
};

///
/// No description in schema.
///
struct shader_KHR_binary_glTF_t {
    /// The id (JSON property name) of the buffer-view that references the
    /// shader source. Use this instead of the shader's uri property. [required]
    std::string bufferView;
};

///
/// A vertex or fragment shader.
///
struct shader_t : glTFChildOfRootProperty_t {
    /// Values for type
    enum struct type_t {
        fragment_shader_t = 35632,
        vertex_shader_t = 35633,
    };

    /// The shader stage. [required]
    type_t type;
    /// The uri of the GLSL source. [required]
    std::string uri;
    /// [extension] See shader_KHR_binary_glTF_t
    optional<shader_KHR_binary_glTF_t> KHR_binary_glTF;

    /// loaded shader data
    shader_data_t data;
};

///
/// Joints and matrices defining a skin.
///
struct skin_t : glTFChildOfRootProperty_t {
    /// Floating-point 4x4 transformation matrix stored in column-major order.
    std::array<float, 16> bindShapeMatrix = {
        1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
    /// The ID of the accessor containing the floating-point 4x4 inverse-bind
    /// matrices.  The default is that each matrix is a 4x4 identity matrix,
    /// which implies that inverse-bind matrices were pre-applied.
    std::string inverseBindMatrices;
    /// Joint names of the joints (nodes with a `jointName` property) in this
    /// skin. [required]
    std::vector<std::string> jointNames;
};

///
/// An attribute or uniform input to a technique, and an optional semantic and
/// value.
///
struct technique_parameters_t : glTFProperty_t {
    /// Values for type
    enum struct type_t {
        byte_t = 5120,
        unsigned_byte_t = 5121,
        short_t = 5122,
        unsigned_short_t = 5123,
        int_t = 5124,
        unsigned_int_t = 5125,
        float_t = 5126,
        float_vec2_t = 35664,
        float_vec3_t = 35665,
        float_vec4_t = 35666,
        int_vec2_t = 35667,
        int_vec3_t = 35668,
        int_vec4_t = 35669,
        bool_t = 35670,
        bool_vec2_t = 35671,
        bool_vec3_t = 35672,
        bool_vec4_t = 35673,
        float_mat2_t = 35674,
        float_mat3_t = 35675,
        float_mat4_t = 35676,
        sampler_2d_t = 35678,
    };

    /// When defined, the parameter is an array of count elements of the
    /// specified type.  Otherwise, the parameter is not an array.
    int count;
    /// The id of the node whose transform is used as the parameter's value.
    std::string node;
    /// Identifies a parameter with a well-known meaning.
    std::string semantic;
    /// The datatype. [required]
    type_t type;
    /// The value of the parameter.
    arrayValues_t value;
};

///
/// Arguments for fixed-function rendering state functions other than
/// `enable()`/`disable()`.
///
struct technique_states_functions_t : glTFProperty_t {
    /// Values for blendEquationSeparate
    enum struct blendEquationSeparate_t {
        func_add_t = 32774,
        func_subtract_t = 32778,
        func_reverse_subtract_t = 32779,
    };

    /// Values for blendFuncSeparate
    enum struct blendFuncSeparate_t {
        zero_t = 0,
        one_t = 1,
        src_color_t = 768,
        one_minus_src_color_t = 769,
        dst_color_t = 774,
        one_minus_dst_color_t = 775,
        src_alpha_t = 770,
        one_minus_src_alpha_t = 771,
        dst_alpha_t = 772,
        one_minus_dst_alpha_t = 773,
        constant_color_t = 32769,
        one_minus_constant_color_t = 32770,
        constant_alpha_t = 32771,
        one_minus_constant_alpha_t = 32772,
        src_alpha_saturate_t = 776,
    };

    /// Values for cullFace
    enum struct cullFace_t {
        front_t = 1028,
        back_t = 1029,
        front_and_back_t = 1032,
    };

    /// Values for depthFunc
    enum struct depthFunc_t {
        never_t = 512,
        less_t = 513,
        lequal_t = 515,
        equal_t = 514,
        greater_t = 516,
        notequal_t = 517,
        gequal_t = 518,
        always_t = 519,
    };

    /// Values for frontFace
    enum struct frontFace_t {
        cw_t = 2304,
        ccw_t = 2305,
    };

    /// Floating-point values passed to `blendColor()`. [red, green, blue,
    /// alpha]
    std::array<float, 4> blendColor = {0, 0, 0, 0};
    /// Integer values passed to `blendEquationSeparate()`.
    std::array<blendEquationSeparate_t, 2> blendEquationSeparate = {
        blendEquationSeparate_t::func_add_t,
        blendEquationSeparate_t::func_add_t};
    /// Integer values passed to `blendFuncSeparate()`.
    std::array<blendFuncSeparate_t, 4> blendFuncSeparate = {
        blendFuncSeparate_t::one_t, blendFuncSeparate_t::zero_t,
        blendFuncSeparate_t::one_t, blendFuncSeparate_t::zero_t};
    /// Boolean values passed to `colorMask()`. [red, green, blue, alpha].
    std::array<bool, 4> colorMask = {true, true, true, true};
    /// Integer value passed to `cullFace()`.
    std::array<cullFace_t, 1> cullFace = {cullFace_t::back_t};
    /// Integer values passed to `depthFunc()`.
    std::array<depthFunc_t, 1> depthFunc = {depthFunc_t::less_t};
    /// Boolean value passed to `depthMask()`.
    std::array<bool, 1> depthMask = {true};
    /// Floating-point values passed to `depthRange()`. [zNear, zFar]
    std::array<float, 2> depthRange = {0, 1};
    /// Integer value passed to `frontFace()`.
    std::array<frontFace_t, 1> frontFace = {frontFace_t::ccw_t};
    /// Floating-point value passed to `lineWidth()`.
    std::array<float, 1> lineWidth = {1};
    /// Floating-point value passed to `polygonOffset()`.  [factor, units]
    std::array<float, 2> polygonOffset = {0, 0};
};

///
/// Fixed-function rendering states.
///
struct technique_states_t : glTFProperty_t {
    /// Values for enable
    enum struct enable_t {
        blend_t = 3042,
        cull_face_t = 2884,
        depth_test_t = 2929,
        polygon_offset_fill_t = 32823,
        sample_alpha_to_coverage_t = 32926,
    };

    /// WebGL states to enable.
    std::vector<enable_t> enable;
    /// No description in schema.
    technique_states_functions_t functions;
};

///
/// A template for material appearances.
///
struct technique_t : glTFChildOfRootProperty_t {
    /// A dictionary object of strings that maps GLSL attribute names to
    /// technique parameter IDs.
    std::map<std::string, std::string> attributes;
    /// A dictionary object of technique.parameters objects.
    std::map<std::string, technique_parameters_t> parameters;
    /// The ID of the program. [required]
    std::string program;
    /// Fixed-function rendering states.
    technique_states_t states;
    /// A dictionary object of strings that maps GLSL uniform names to technique
    /// parameter IDs.
    std::map<std::string, std::string> uniforms;
};

///
/// A texture and its sampler.
///
struct texture_t : glTFChildOfRootProperty_t {
    /// Values for format
    enum struct format_t {
        alpha_t = 6406,
        rgb_t = 6407,
        rgba_t = 6408,
        luminance_t = 6409,
        luminance_alpha_t = 6410,
    };

    /// Values for internalFormat
    enum struct internalFormat_t {
        alpha_t = 6406,
        rgb_t = 6407,
        rgba_t = 6408,
        luminance_t = 6409,
        luminance_alpha_t = 6410,
    };

    /// Values for target
    enum struct target_t {
        texture_2d_t = 3553,
    };

    /// Values for type
    enum struct type_t {
        unsigned_byte_t = 5121,
        unsigned_short_5_6_5_t = 33635,
        unsigned_short_4_4_4_4_t = 32819,
        unsigned_short_5_5_5_1_t = 32820,
    };

    /// The texture's format.
    format_t format = format_t::rgba_t;
    /// The texture's internal format.
    internalFormat_t internalFormat = internalFormat_t::rgba_t;
    /// The ID of the sampler used by this texture. [required]
    std::string sampler;
    /// The ID of the image used by this texture. [required]
    std::string source;
    /// The target that the WebGL texture should be bound to.
    target_t target = target_t::texture_2d_t;
    /// Texel datatype.
    type_t type = type_t::unsigned_byte_t;
};

///
/// No description in schema.
///
struct light_ambient_KHR_materials_common_t : glTFProperty_t {
    /// RGB color of the light source.
    std::array<float, 3> color = {1, 1, 1};
};

///
/// No description in schema.
///
struct light_directional_KHR_materials_common_t : glTFProperty_t {
    /// RGB color of the light source.
    std::array<float, 3> color = {1, 1, 1};
};

///
/// No description in schema.
///
struct light_point_KHR_materials_common_t : glTFProperty_t {
    /// RGB color of the light source.
    std::array<float, 3> color = {1, 1, 1};
    /// Constant attenuation factor.
    float constantAttenuation = 1;
    /// Linear attenuation factor.
    float linearAttenuation = 0;
    /// Quadratic attenuation factor.
    float quadraticAttenuation = 0;
};

///
/// No description in schema.
///
struct light_spot_KHR_materials_common_t : glTFProperty_t {
    /// RGB color of the light source.
    std::array<float, 3> color = {1, 1, 1};
    /// Constant attenuation factor.
    float constantAttenuation = 1;
    /// Fall off angle in radians.
    float fallOffAngle = 3.141593;
    /// Fall off exponent.
    float fallOffExponent = 0;
    /// Linear attenuation factor.
    float linearAttenuation = 0;
    /// Quadratic attenuation factor.
    float quadraticAttenuation = 0;
};

///
/// An ambient, directional, point, or spot light.
///
struct light_KHR_materials_common_t : glTFChildOfRootProperty_t {
    /// Values for type
    enum struct type_t {
        ambient_t = 0,
        directional_t = 1,
        point_t = 2,
        spot_t = 3,
    };

    /// Ambient light source.
    light_ambient_KHR_materials_common_t ambient;
    /// Directional light source.
    light_directional_KHR_materials_common_t directional;
    /// Point light source.
    light_point_KHR_materials_common_t point;
    /// Spot light source.
    light_spot_KHR_materials_common_t spot;
    /// Specifies the light type. [required]
    type_t type;
};

///
/// No description in schema.
///
struct glTF_KHR_materials_common_t {
    /// No description in schema.
    std::map<std::string, light_KHR_materials_common_t> lights;
};

///
/// The root object for a glTF asset.
///
struct glTF_t : glTFProperty_t {
    /// Values for glExtensionsUsed
    enum struct glExtensionsUsed_t {
        oes_element_index_uint_t = 0,
    };

    /// A dictionary object of accessors. [required]
    std::map<std::string, accessor_t> accessors;
    /// A dictionary object of keyframe animations.
    std::map<std::string, animation_t> animations;
    /// Metadata about the glTF asset. [required]
    asset_t asset;
    /// A dictionary object of bufferViews. [required]
    std::map<std::string, bufferView_t> bufferViews;
    /// A dictionary object of buffers. [required]
    std::map<std::string, buffer_t> buffers;
    /// A dictionary object of cameras.
    std::map<std::string, camera_t> cameras;
    /// Names of glTF extensions required to properly load this asset.
    std::vector<std::string> extensionsRequired;
    /// Names of glTF extensions used somewhere in this asset.
    std::vector<std::string> extensionsUsed;
    /// Names of WebGL extensions required to render this asset.
    std::vector<glExtensionsUsed_t> glExtensionsUsed;
    /// A dictionary object of images.
    std::map<std::string, image_t> images;
    /// A dictionary object of materials.
    std::map<std::string, material_t> materials;
    /// A dictionary object of meshes. [required]
    std::map<std::string, mesh_t> meshes;
    /// A dictionary object of nodes.
    std::map<std::string, node_t> nodes;
    /// A dictionary object of programs.
    std::map<std::string, program_t> programs;
    /// A dictionary object of samplers.
    std::map<std::string, sampler_t> samplers;
    /// The ID of the default scene.
    std::string scene;
    /// A dictionary object of scenes.
    std::map<std::string, scene_t> scenes;
    /// A dictionary object of shaders.
    std::map<std::string, shader_t> shaders;
    /// A dictionary object of skins.
    std::map<std::string, skin_t> skins;
    /// A dictionary object of techniques.
    std::map<std::string, technique_t> techniques;
    /// A dictionary object of textures.
    std::map<std::string, texture_t> textures;
    /// [extension] See glTF_KHR_materials_common_t
    optional<glTF_KHR_materials_common_t> KHR_materials_common;
};

// #codegen end type -----------------------------------------------------------

///
/// Error when reading/writing gltf.
///
struct gltf_exception : std::exception {
    /// constructor with error message
    gltf_exception(const std::string& errmsg) : _errmsg(errmsg) {}

    /// retieval of error message
    virtual const char* what() const throw() { return _errmsg.c_str(); }

   private:
    std::string _errmsg;
};

///
/// Loads a gltf file from disk
///
/// Parameters:
/// - filename: scene filename
/// - load_bin/load_shaders/load_img: load binary data
/// - skip_missing: do not throw an exception if a file is missing
///
/// Returns:
/// - gltf data loaded
///
/// Throw:
/// - io_exception: on read/write error
///
YGLTF_API glTF_t* load_gltf(const std::string& filename, bool load_bin = true,
    bool load_shaders = true, bool load_img = true, bool skip_missing = false);

///
/// Loads a binary gltf file from disk
///
/// Parameters:
/// - filename: scene filename
/// - other params as above
///
/// Returns:
/// - gltf data loaded
///
/// Throw:
/// - io_exception: on read/write error
///
YGLTF_API glTF_t* load_binary_gltf(const std::string& filename,
    bool load_bin = true, bool load_shaders = true, bool load_img = true,
    bool skip_missing = false);

///
/// Saves a scene to disk
///
/// Parameters:
/// - filename: scene filename
/// - gltf: data to save
/// - save_bin/save_shaders/save_img: save binary data
///
/// Throw:
/// - io_exception: on read/write error
///
YGLTF_API void save_gltf(const std::string& filename, const glTF_t* gltf,
    bool save_bin = true, bool save_shaders = true, bool save_images = true);

///
/// Saves a scene to disk
///
/// Parameters:
/// - filename: scene filename
/// - gltf: data to save
/// - save_bin/save_shaders/save_img: save binary data
///
/// Throw:
/// - io_exception: on read/write error
///
YGLTF_API void save_binary_gltf(const std::string& filename, const glTF_t* gltf,
    bool save_bin = true, bool save_shaders = true, bool save_images = true);

///
/// Load buffer data.
///
/// Parameters:
/// - dirname: directory used to resolve path references
/// - skip_missing: do not throw an exception if a file is missing
///
/// Out Parameters:
/// - gltf: data to data
///
/// Throw:
/// - io_exception: on read/write error
///
YGLTF_API void load_buffers(
    glTF_t* gltf, const std::string& dirname, bool skip_missing = false);

///
/// Load shaders data.
///
/// Parameters:
/// - dirname: directory used to resolve path references
/// - skip_missing: do not throw an exception if a file is missing
///
/// Out Parameters:
/// - gltf: data to data
///
/// Throw:
/// - io_exception: on read/write error
///
YGLTF_API void load_shaders(
    glTF_t* asset, const std::string& dirname, bool skip_missing = false);

///
/// Loads images.
///
/// Parameters:
/// - dirname: directory used to resolve path references
/// - skip_missing: do not throw an exception if a file is missing
///
/// Out Parameters:
/// - gltf: data to data
///
/// Throw:
/// - io_exception: on read/write error
///
YGLTF_API void load_images(
    glTF_t* asset, const std::string& dirname, bool skip_missing = false);

///
/// Save buffer data.
///
/// Parameters:
/// - dirname: directory used to resolve path references
/// - gltf: data to save
///
/// Throw:
/// - io_exception: on read/write error
///
YGLTF_API void save_buffers(const glTF_t* gltf, const std::string& dirname);

///
/// Save shaders data.
///
/// Parameters:
/// - dirname: directory used to resolve path references
/// - gltf: data to save
///
/// Throw:
/// - io_exception: on read/write error
///
YGLTF_API void save_shaders(const glTF_t* asset, const std::string& dirname);

///
/// Saves images.
///
/// Parameters:
/// - dirname: directory used to resolve path references
/// - gltf: data to save
///
/// Throw:
/// - io_exception: on read/write error
///
YGLTF_API void save_images(const glTF_t* asset, const std::string& dirname);

///
/// Loads a gltf asset from disk
///
/// Parameters:
/// - filename: scene filename
/// - load_bin/load_shaders/load_img: load binary data
/// - skip_missing: do not throw an exception if a file is missing
///
/// Out Parameters:
/// - gltf data loaded
/// - errmsg: holds an error message upon error
///
/// Returns:
/// - true if ok
///
YGL_DEPRECATED YGLTF_API bool load_gltf(const std::string& filename,
    glTF_t& gltf, std::string& errmsg, bool load_bin = true,
    bool load_shaders = true, bool load_img = true, bool skip_missing = false);

///
/// Loads a binary gltf asset from disk
///
/// Parameters:
/// - filename: scene filename
/// - other params as above
///
/// Out Parameters:
/// - gltf data loaded
/// - errmsg: holds an error message upon error
///
/// Returns:
/// - true if ok
///
YGL_DEPRECATED YGLTF_API bool load_binary_gltf(const std::string& filename,
    glTF_t& gltf, std::string& errmsg, bool load_bin = true,
    bool load_shaders = true, bool load_img = true, bool skip_missing = false);

///
/// Saves a scene to disk
///
/// Parameters:
/// - filename: scene filename
/// - asset: asset to save
///
/// Out Parameters:
/// - errmsg: error message upon error
///
/// Returns:
/// - true if ok
///
YGL_DEPRECATED YGLTF_API bool save_gltf(const std::string& filename,
    const glTF_t& gltf, std::string& errmsg, bool save_bin = true,
    bool save_shaders = true, bool save_images = true);

///
/// Saves a scene to disk
///
/// Parameters:
/// - filename: scene filename
/// - asset: asset to save
///
/// Out Parameters:
/// - errmsg: error message upon error
///
/// Returns:
/// - true if ok
///
YGL_DEPRECATED YGLTF_API bool save_binary_gltf(const std::string& filename,
    const glTF_t& gltf, std::string& errmsg, bool save_bin = true,
    bool save_shaders = true, bool save_images = true);

///
/// Load buffer data.
///
/// Parameters:
/// - dirname: directory used to resolve path references
///
/// Out Parameters:
/// - asset: gltf data
/// - errmsg: if set, holds an error message upon error
/// - skip_missing: do not throw an exception if a file is missing
///
/// Returns:
/// - true if ok
///
YGL_DEPRECATED YGLTF_API bool load_buffers(glTF_t& gltf,
    const std::string& dirname, std::string& errmsg, bool skip_missing = false);

///
/// Load shaders data.
///
/// Parameters:
/// - dirname: directory used to resolve path references
///
/// Out Parameters:
/// - asset: gltf data
/// - errmsg: if set, holds an error message upon error
/// - skip_missing: do not throw an exception if a file is missing
///
/// Returns:
/// - true if ok
///
YGL_DEPRECATED YGLTF_API bool load_shaders(glTF_t& asset,
    const std::string& dirname, std::string& errmsg, bool skip_missing = false);

///
/// Loads images.
///
/// Parameters:
/// - dirname: directory used to resolve path references
/// - errmsg: if set, holds an error message upon error
/// - skip_missing: do not throw an exception if a file is missing
///
/// Out Parameters:
/// - asset: gltf data
/// - errmsg: if set, holds an error message upon error
///
/// Returns:
/// - true if ok
///
YGL_DEPRECATED YGLTF_API bool load_images(glTF_t& asset,
    const std::string& dirname, std::string& errmsg, bool skip_missing = false);

///
/// Save buffer data.
///
/// Parameters:
/// - dirname: directory used to resolve path references
///
/// Out Parameters:
/// - asset: gltf data
/// - errmsg: if set, holds an error message upon error
///
/// Returns:
/// - true if ok
///
YGL_DEPRECATED YGLTF_API bool save_buffers(
    const glTF_t& gltf, const std::string& dirname, std::string& errmsg);

///
/// Save shaders data.
///
/// Parameters:
/// - dirname: directory used to resolve path references
///
/// Out Parameters:
/// - asset: gltf data
/// - errmsg: if set, holds an error message upon error
///
/// Returns:
/// - true if ok
///
YGL_DEPRECATED YGLTF_API bool save_shaders(
    const glTF_t& asset, const std::string& dirname, std::string& errmsg);

///
/// Saves images.
///
/// Parameters:
/// - dirname: directory used to resolve path references
/// - whether to force loading float images
///
/// Out Parameters:
/// - asset: gltf data
/// - errmsg: if set, holds an error message upon error
///
/// Returns:
/// - true if ok
///
YGL_DEPRECATED YGLTF_API bool save_images(
    const glTF_t& asset, const std::string& dirname, std::string& errmsg);

///
/// A view for gltf array buffers that allows for typed access.
///
struct vec_array_view {
    vec_array_view(const glTF_t* gltf, const accessor_t& accessor);

    int size() const { return _size; }
    int count() const { return _size; }
    int ncomp() const { return _ncomp; }

    std::array<float, 4> operator[](int idx) const;

   private:
    const unsigned char* _data = nullptr;
    int _size = 0;
    int _stride = 0;
    int _ncomp = 0;
    accessor_t::componentType_t _ctype;
    bool _normalize = false;

    static int _num_components(accessor_t::type_t type);
    static int _ctype_size(accessor_t::componentType_t componentType);
};

///
/// A view for gltf element array buffers that allows for typed access.
///
struct element_array_view {
    element_array_view(const glTF_t* gltf, const accessor_t& accessor);

    int size() const { return _size; }

    int operator[](int idx) const;

   private:
    const unsigned char* _data = nullptr;
    int _size = 0;
    int _stride = 0;
    accessor_t::componentType_t _ctype;

    static int _ctype_size(accessor_t::componentType_t componentType);
};

///
/// Computes the local node transform and its inverse.
///
YGLTF_API std::array<float, 16> node_transform(const node_t* node);

// -----------------------------------------------------------------------------
// HIGH-LEVEL, FLATTENED, INTERFACE
// -----------------------------------------------------------------------------

///
/// Camera
///
struct fl_camera {
    std::string name = "";  // name
    std::array<float, 16> xform = {
        1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};  // transform
    bool ortho = false;                                   // orthographic
    float aspect = 1;                                     // aspect ratio
    float yfov =
        2 *
        std::atan(0.5f);  // vertical fov (perspective) or size (orthographic)
};

///
/// Primitives
///
struct fl_primitives {
    /// name of the mesh that enclosed it
    std::string name = "";
    /// material reference
    int material = -1;

    /// vertex position
    std::vector<std::array<float, 3>> pos;
    /// vertex normal
    std::vector<std::array<float, 3>> norm;
    /// vertex texcoord
    std::vector<std::array<float, 2>> texcoord;
    /// vertex color
    std::vector<std::array<float, 3>> color;
    /// vertex radius
    std::vector<float> radius;

    /// point elements
    std::vector<int> points;
    /// line elements
    std::vector<std::array<int, 2>> lines;
    /// triangle elements
    std::vector<std::array<int, 3>> triangles;
};

///
/// Material
///
struct fl_material {
    /// name
    std::string name = "";
    /// emission color
    std::array<float, 3> ke = {0, 0, 0};
    /// diffuse color
    std::array<float, 3> kd = {0, 0, 0};
    /// specular color
    std::array<float, 3> ks = {0, 0, 0};
    /// specular roughness
    float rs = 0;
    /// emissive texture reference
    int ke_txt = -1;
    /// diffuse texture reference
    int kd_txt = -1;
    /// specualr texture reference
    int ks_txt = -1;
    /// roughness texture reference
    int rs_txt = -1;
};

///
/// Texture
///
struct fl_texture {
    /// name
    std::string name = "";
    /// path
    std::string path = "";
    /// image width
    int width = 0;
    /// image height
    int height = 0;
    /// image number of components
    int ncomp = 0;
    /// 8-bit data
    std::vector<uint8_t> datab;
    /// float data
    std::vector<float> dataf;
};

///
/// Gltf mesh. A collection of primitives with transforms.
///
struct fl_mesh {
    /// name
    std::string name = "";
    /// transform
    std::array<float, 16> xform = {
        1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};
    /// primitives
    std::vector<int> primitives;
};

///
/// Gltf scene
///
struct fl_scene {
    /// name
    std::string name = "";
    /// cameras
    std::vector<int> cameras;
    /// materials
    std::vector<int> materials;
    /// textures
    std::vector<int> textures;
    /// primitives
    std::vector<int> primitives;
    /// meshes
    std::vector<int> meshes;
    /// transforms
    std::vector<int> transforms;
};

///
/// Gltf asset with multiple scenes
///
struct fl_gltf {
    /// default scene (-1 if only one scene is present)
    int default_scene = -1;
    /// cameras
    std::vector<fl_camera*> cameras;
    /// materials
    std::vector<fl_material*> materials;
    /// textures
    std::vector<fl_texture*> textures;
    /// mesh primitives
    std::vector<fl_primitives*> primitives;
    /// meshes
    std::vector<fl_mesh*> meshes;
    /// scenes
    std::vector<fl_scene*> scenes;
};

///
/// Convert a gltf asset to flattened scenes.
///
YGLTF_API fl_gltf* flatten_gltf(
    const glTF_t* gltf, const std::string& scene_name = "");

///
/// Convert a flattened gltf to a raw one.
///
YGLTF_API glTF_t* unflatten_gltf(
    const fl_gltf* fl_gltf, const std::string& buffer_uri);

///
/// Convert a gltf asset to flattened scenes.
///
YGL_DEPRECATED YGLTF_API fl_gltf flatten_gltf(
    const glTF_t& gltf, const std::string& scene_name = "");

///
/// Convert a gltf asset to flattened scenes.
///
YGL_DEPRECATED YGLTF_API glTF_t unflatten_gltf(
    const fl_gltf& fl_gltf, const std::string& buffer_uri);
}  // namespace

// -----------------------------------------------------------------------------
// INCLUDE FOR HEADER-ONLY MODE
// -----------------------------------------------------------------------------

#ifdef YGLTF_INLINE
#include "yocto_gltf.cpp"
#endif

#endif
